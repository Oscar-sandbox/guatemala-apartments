# -*- coding: utf-8 -*-
"""citymap-apartments.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EdrhP7E5AD-vIthzog8XNUG_0DQICW8U

#Setup
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install h3

from google.colab import files
import json
import re

import numpy as np
import pandas as pd
import geopandas as gpd
from shapely.geometry import Polygon
import h3

import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

from sklearn.linear_model import LinearRegression
from sklearn.neighbors import RadiusNeighborsRegressor

pd.set_option('display.max_columns', None)

"""# Load Data"""

# Load apartments csv and zone borders geojson.
# Geojson available at https://sig.muniguate.com/tmp/rest/services/Mapas_base/zonas/MapServer/0/query.
_ = files.upload()

df = pd.read_csv('citymap_apartments_20250318.csv')\
  .drop_duplicates(ignore_index=True)

zone_borders = gpd.read_file('zones.json')

df.head()

df.info()

df.describe(include='all')

# In df, (project_name, apartment_type) is almost unique, but some apartments
# of the "same" apartment type have slight variations.
print('Number of unique apartment projects:',
 len(df.value_counts(['project_name'])))
print('Number of unique apartment types:',
 len(df.value_counts(['project_name', 'apartment_type'])))

"""# Preprocessing"""

# Replace a wrong value at a given apartment.
def clean_value(df, project_name, apartment_type, var, old_val, new_val):
  index = (df['project_name'] == project_name) \
    & (df['apartment_type'] == apartment_type)
  index &= (df[var] == old_val) if old_val else df[var].isna()
  assert index.sum() == 1
  df.loc[index, var] = new_val

# Rename and reorder columns.
new_columns = {
  'Metraje': 'apartment_m2',
  'Cantidad de habitaciones': 'apartment_beds',
  'Baños': 'apartment_baths',
  'Parqueos': 'apartment_parking',
  'Incluye área de servicio': 'apartment_has_serviceroom',
  'Incluye bodega': 'apartment_has_storeroom',
  'Cuotas desde': 'apartment_rent',
  'Precio desde': 'apartment_price',
}
column_order = [
  'project_name', 'apartment_type', 'project_url', 'project_description',
  'project_c_time', 'project_m_time', 'project_img_url', 'project_zone',
  'project_status', 'project_lat', 'project_lon', 'apartment_m2',
  'apartment_beds', 'apartment_baths', 'apartment_parking',
  'apartment_has_serviceroom', 'apartment_has_storeroom',
  'apartment_rent', 'apartment_price'
]
df = df.rename(columns=new_columns)[column_order]

# Process creation and modification dates.
df['project_c_date'] = pd.to_datetime(df['project_c_time']).dt.date
df['project_m_date'] = pd.to_datetime(df['project_m_time']).dt.date
df = df.drop(columns=['project_c_time', 'project_m_time'])

# Process status.
df.replace({'project_status': {'Null': None}}, inplace=True)

# Correct locations.
df.loc[df['project_name'] == 'vidalta', 'project_lon'] = -90.55304

# Process apartment footage in meters squared.
df['apartment_m2'] = df['apartment_m2']\
  .str.extract('([\d.,]+)m²')\
  .astype(float)

# Correct and process number of beds, baths and parking spots.
clean_value(df, 'via-pulte', 'Apto C702', 'apartment_baths', '33.5', np.nan)
clean_value(df, 'essenza-apartamentos', 'Tipo F', 'apartment_parking', '12', np.nan)

df['apartment_beds'] = pd.to_numeric(df['apartment_beds'], errors='coerce')
df['apartment_baths'] = pd.to_numeric(df['apartment_baths'], errors='coerce')
df['apartment_parking'] = pd.to_numeric(df['apartment_parking'], errors='coerce')
df.replace({'apartment_has_serviceroom': {'Si': True}}, inplace=True)
df.replace({'apartment_has_storeroom': {'Si': True}}, inplace=True)

# Correct and process rent and price in dollars.
clean_value(df, 'villa-isabel', 'Tipo E', 'apartment_rent', 'Q5.812', 'Q5,812')
clean_value(df, 'piera-ciudad-vieja', '2H', 'apartment_rent', 'Q1,750,000', 'Q8,950')
clean_value(df, 'piera-ciudad-vieja', '2H', 'apartment_price', 'Q8,950', 'Q1,750,000')
clean_value(df, 'vicinia-las-americas',	'Vicinia Bold', 'apartment_price', 'Q1,134.700', 'Q1,134,700')
clean_value(df, 'torrus',	'C', 'apartment_price', 'Q5,092', np.nan)
clean_value(df, 'torrus',	'C', 'apartment_rent', None, 'Q5,092')
clean_value(df, 'serene', 'APARTAMENTO B', 'apartment_price', 'Q70,600', np.nan)

df['apartment_rent_currency'] = df['apartment_rent'].str.extract('([$Q])')
df['apartment_price_currency'] = df['apartment_price'].str.extract('([$Q])')

df['apartment_rent'] = df['apartment_rent']\
  .str.replace('[Q$,+]', '', regex=True)\
  .replace('', np.nan)\
  .astype(float)

df['apartment_price'] = df['apartment_price']\
  .str.replace('[Q$,+]', '', regex=True)\
  .replace('', np.nan)\
  .astype(float)

df.loc[df['apartment_rent_currency'] == 'Q', 'apartment_rent'] /= 7.8
df.loc[df['apartment_price_currency'] == 'Q', 'apartment_price'] /= 7.8
df = df.drop(columns=['apartment_rent_currency', 'apartment_price_currency'])

# Compute rent and price per squared meter.
df['apartment_rent_m2'] = df['apartment_rent'] / df['apartment_m2']
df['apartment_price_m2'] = df['apartment_price'] / df['apartment_m2']

# Round numerical features.
round_cols = ['apartment_m2', 'apartment_rent','apartment_price',
  'apartment_rent_m2', 'apartment_price_m2']
df[round_cols] = df[round_cols].round(2)

df.to_csv('citymap_apartments_20250318_clean.csv', index=False)

df.info()

df.describe(include='all')

"""# EDA"""

# Projects were published from 2020 to 2025, with spikes in 2020, 2021
# and 2024. Most data is updated to 2024.
fig, ax = plt.subplots(1, 2, figsize=(12, 4))
sns.barplot(data=df\
  .groupby('project_name')['project_c_date'].first()
  .apply(lambda d: d.year)\
  .value_counts()\
  .sort_index(), ax=ax[0]
)
sns.barplot(data=df\
  .groupby('project_name')['project_m_date'].first()
  .apply(lambda d: d.year)\
  .value_counts()\
  .sort_index(), ax=ax[1]
)
ax[0].set_title('Project publication year')
ax[1].set_title('Project modification year')

!mkdir eda
fig.savefig('eda/project_date.png', bbox_inches='tight')

# Most apartments have 2-3 beds, 2 baths and 2 parking spots.
fig, ax = plt.subplots(1, 3, figsize=(12, 3))
sns.barplot(data=df['apartment_beds'].value_counts(), ax=ax[0])
sns.barplot(data=df['apartment_baths'].value_counts(), ax=ax[1])
sns.barplot(data=df['apartment_parking'].value_counts(), ax=ax[2])

ax[0].set_title('Number of beds')
ax[1].set_title('Number of baths')
ax[2].set_title('Number of parking spots')
fig.savefig('eda/apartment_beds.png', bbox_inches='tight')

# Distributions of apartment price and rent.
fig, ax = plt.subplots(2, 2, figsize=(12, 7))

sns.histplot(data=df['apartment_price'], bins=20, ax=ax[0,0])
sns.histplot(data=df['apartment_rent'], bins=20, ax=ax[0,1])
sns.histplot(data=df['apartment_price_m2'], bins=20, ax=ax[1,0])
sns.histplot(data=df['apartment_rent_m2'], bins=20, ax=ax[1,1])

ax[0,0].xaxis.set_major_formatter(lambda x, pos: f'{x/1e3:.0f}k')
ax[0,0].set_title('Apartment price')
ax[0,1].set_title('Apartment rent')
ax[1,0].set_title('Apartment price/m²')
ax[1,1].set_title('Apartment rent/m²')
_ = [ax[i,j].set_xlabel('') for i in range(2) for j in range(2)]
fig.savefig('eda/apartment_price.png', bbox_inches='tight')

# There are 344 apartment projects in the dataset.
# Of these, only 55 projects have at least one apartment with info about
# footage and price. Only zones 10, 13, 14, 15, 16, as well as mixco and
# carretera al salvador have more that two projects with price/m² known.
fig, ax = plt.subplots(1, 2, figsize=(12, 4))

project_count_0 = df\
  .groupby('project_zone')['project_name']\
  .nunique()\
  .rename('count')\
  .sort_values(ascending=False)

project_count_1 = df[df['apartment_price_m2'].notna()]\
  .groupby('project_zone')['project_name']\
  .nunique()\
  .rename('count')\
  .sort_values(ascending=False)

sns.barplot(data=project_count_0, ax=ax[0])
sns.barplot(data=project_count_1, ax=ax[1])
ax[0].set_title('Project count by zone')
ax[1].set_title('Project count (with price/m²) by zone')
ax[0].tick_params(axis='x', labelrotation=90)
ax[1].tick_params(axis='x', labelrotation=90)
fig.savefig('eda/project_count_zone.png', bbox_inches='tight')

# The median price per squared meter was computed for each project in
# in the 7 zones mentioned above. These medians were then grouped by
# zone and presented in a boxplot. The zones with the highest median of
# medians are zones 14, 13 and 10, with values around $2.5k/m².
top_zones = project_count_1[project_count_1 > 2].index

project_median_price_m2 = df\
  .dropna(subset=['apartment_price_m2'])\
  .groupby('project_name')\
  .agg({
    'apartment_price_m2': 'median',
    'project_zone': 'first'
  })\
  .rename(columns={'apartment_price_m2': 'project_median_price_m2'})\
  .query('project_zone in @top_zones')

order = project_median_price_m2\
  .groupby('project_zone')['project_median_price_m2']\
  .median()\
  .sort_values(ascending=False)\
  .index

fig, ax = plt.subplots(1, 1, figsize=(6, 4))
ax = sns.boxplot(data=project_median_price_m2,
  x='project_zone', y='project_median_price_m2', order=order)

ax.set_title('Project median price/m² by zone')
ax.tick_params(axis='x', labelrotation=90)
fig.savefig('eda/project_price_zone.png', bbox_inches='tight')

# We now plot each apartment in a price vs m² grid, colored by zone, for the
# first 3 zones in the previous plot. When fitting a linear model without
# intercept for each zone, zones 14, 13 and 10 exhibit lower price per
# squared meter. Zones 10 and 14 are around $2.3k/m², while zone 13 is at
# $2k/m². This is due to outliers: very large apartments with low price per m².
top_zones = ['zona-10','zona-13','zona-14']

fig, ax = plt.subplots(1, 1, figsize=(6, 4))
ax = sns.scatterplot(data=df[df['project_zone'].isin(top_zones)],
  x='apartment_m2', y='apartment_price', hue='project_zone')
ax.set_title('Apartment price vs m²')

for z in top_zones:
  df_reg = df\
    .dropna(subset=['apartment_price_m2'])\
    .query('project_zone == @z')
  reg = LinearRegression(fit_intercept=False)
  reg.fit(df_reg[['apartment_m2']], df_reg['apartment_price'])
  ax.plot([30,150], [30*reg.coef_,150*reg.coef_], zorder=-1)
  print(f'Estimated price/m² in {z}: ${reg.coef_[0]:.0f}/m²')

fig.savefig('eda/apartment_price_m2.png', bbox_inches='tight')

!zip -r eda.zip eda

"""# Maps"""

# We construct an interactive scatter plot showing the geolocations of
# every project in a map, along with a summary and some statistics
# of each project. Also, we show predicted prices for regions
# near these projects.

# Collect data and compute statistics for each project.
projects = df\
  .groupby('project_name')\
  .agg(
    lat=('project_lat', 'first'),
    lon=('project_lon', 'first'),
    zone=('project_zone', 'first'),
    c_date=('project_c_date', 'first'),
    m_date=('project_m_date', 'first'),
    m2_list=('apartment_m2', list),
    price_list=('apartment_price', list),
    price_m2_list=('apartment_price_m2', list),
    price_m2_median=('apartment_price_m2', 'median'),
  )\
  .reset_index()

# Construct a string to summarize a project's info. This will be shown
# when hovering over a data point in the map.
def project_str_info(r):
  cols = ['m2_list', 'price_list', 'price_m2_list']
  project = pd\
    .DataFrame(r[cols].to_dict())\
    .sort_values('m2_list')
  project.columns = ['m2', 'price', 'price_m2']

  m2_fmt = lambda x: f'{x:.0f}m²' if ~np.isnan(x) else ''
  price_fmt = lambda x: f'${x/1e3:.0f}k' if ~np.isnan(x) else ''
  price_m2_fmt = lambda x: f'${x/1e3:.2f}k' if ~np.isnan(x) else ''

  project['m2'] = project['m2'].apply(m2_fmt)
  project['price'] = project['price'].apply(price_fmt)
  project['price_m2'] = project['price_m2'].apply(price_m2_fmt)
  project.columns = ['Size', 'Price', 'Price/m²']

  info = project.to_markdown(index=False, tablefmt='github').split('\n')
  info[0] = re.sub('[^|]+', lambda x: f'<b>{x.group()}</b>', info[0])
  r['str_info'] = '<br>'.join(info)
  r['str_price_m2_median'] = price_m2_fmt(r['price_m2_median']) or 'NA'

  return r

projects = projects.apply(project_str_info, axis=1)

# Construct a grid of hexagons that cover Guatemala City, using
# the h3 library developed by Uber.
center_cell = h3.latlng_to_cell(14.59614, -90.51288, res=9)
cells = h3.grid_disk(center_cell, 100)
cells = pd.DataFrame(cells, columns=['hex_id'])

# Save the polygon border of each hexagon, as well as the
# latitude and longitude of their centers.
cells['geometry'] = cells['hex_id']\
  .apply(h3.cell_to_boundary)\
  .apply(lambda r: [ri[::-1] for ri in r])\
  .apply(Polygon)
cells = gpd.GeoDataFrame(cells, crs='EPSG:4326')

cells[['lat','lon']] = cells\
  .apply(lambda r: h3.cell_to_latlng(r['hex_id']),
    axis=1, result_type='expand')

# Project latitudes and longitudes to mercator.
cell_points = gpd.points_from_xy(
    cells['lon'], cells['lat'], crs='EPSG:4326')\
  .to_crs('EPSG:3857')
cells['x'], cells['y'] = cell_points.x, cell_points.y

project_points = gpd.points_from_xy(
    projects['lon'], projects['lat'], crs='EPSG:4326')\
  .to_crs('EPSG:3857')
projects['x'], projects['y'] = project_points.x, project_points.y

# Train a radial nearest neighbors regressor based on the
# projects' price/m², and predict this value for neighboring hex tiles.
# Tiles without neighbors in the specified radius (500m) are dropped.
reg = RadiusNeighborsRegressor(radius=500, weights='distance')
reg.fit(projects.dropna(subset=['price_m2_median'])[['x','y']],
        projects.dropna(subset=['price_m2_median'])['price_m2_median'])
cells['price_m2_median'] = reg.predict(cells[['x','y']])

cells = cells.dropna(subset=['price_m2_median'])
cells = cells.set_index('hex_id')

# Construct a scatter map of the projects, colored by
# median project price/m².
fig_projects = px.scatter_map(projects,
  lat='lat', lon='lon', color='price_m2_median',
  color_continuous_scale='bluered',
  labels={'price_m2_median':'Price/m²'},
  text='project_name',
  custom_data=['zone', 'c_date', 'm_date', 'str_price_m2_median', 'str_info'],
  zoom=10.5, map_style='carto-positron',
  center={'lat': 14.59614, 'lon': -90.51288}
)
fig_projects.update_traces(
  hovertemplate = \
    ' <b>Project:</b> %{text}<br>' \
    ' <b>Location:</b> %{customdata[0]}<br>' \
    ' <b>Published:</b> %{customdata[1]}<br>' \
    ' <b>Modified:</b> %{customdata[2]}<br>' \
    ' <b>Median price/m²:</b> %{customdata[3]}<br><br>' \
    '<span style="font-family:monospace">%{customdata[4]}</span>' \
    '<extra></extra>'
)

# Construct a choropleth map of the hex tiles, colored by
# predicted median project price/m².
fig_hex = px.choropleth_map(cells,
  geojson=cells.geometry,
  locations=cells.index,
  color='price_m2_median', opacity=0.3,
  color_continuous_scale='bluered'
)
fig_hex.update_traces(hoverinfo='skip', hovertemplate=None)
fig_projects.add_trace(fig_hex.data[0])

# Add zone borders, buttons and cosmetics.
map = dict(layers=[
  dict(source=zone_borders.__geo_interface__,
    type='line', below='traces', color='#2a3f5f')
])
buttons = [
  dict(label='Show Predicted Price/m²', args=[{'visible': [True,True]}]),
  dict(label='Hide Predicted Price/m²', args=[{'visible': [True,False]}]),
]
fig_projects.update_layout(
  title='<b>Apartment Projects in Guatemala City</b>',
  margin=dict(r=5,l=5,b=5), map=map,
  updatemenus=[
    dict(buttons=buttons, pad=dict(r=5,t=5,l=5,b=5),
    xanchor='right', x=1, yanchor='top', y=1)
  ]
)

fig_projects.show()
fig_projects.write_html('projects_map.html')